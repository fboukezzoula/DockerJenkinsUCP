Tout d'abord, assurez-vous que votre système dispose de la prise en charge du routage des paquets et de la translation d'adresses. Vous pouvez activer le routage des paquets en exécutant :

bash
Copy code
sudo sysctl -w net.ipv4.ip_forward=1
Ensuite, vous pouvez utiliser iptables pour rediriger le trafic :

bash
Copy code
sudo iptables -t nat -A OUTPUT -d 127.0.0.1 -p tcp --dport 3128 -j DNAT --to-destination 10.88.0.1:3128
Cette commande redirige le trafic TCP sortant destiné à l'adresse IP 127.0.0.1 sur le port 3128 vers l'adresse IP 10.88.0.1 sur le port 3128.

Assurez-vous que votre application écoute bien sur 10.88.0.1:3128 pour accepter ces connexions.

N'oubliez pas que cette redirection de trafic ne survivra pas à un redémarrage de la machine. Pour la rendre permanente, vous devrez ajouter cette règle iptables à vos scripts de démarrage ou utiliser un outil comme iptables-persistent pour sauvegarder et restaurer les règles iptables.





socat TCP-LISTEN:127.0.0.1:3128,fork,reuseaddr TCP:10.88.0.1:3128



socat TCP-LISTEN:3128,fork,reuseaddr TCP:10.88.0.1:3128


---
- name: Exemple de playbook Ansible
  hosts: votre_hôte
  tasks:
    - name: Exécuter la commande shell et récupérer la sortie
      command: "podman network inspect podman"
      register: resultat_commande

    - name: Extraire la gateway de la sortie JSON
      set_fact:
        gateway_variable: "{{ resultat_commande.stdout | from_json | json_query('[0].subnets[0].gateway') }}"

    - name: Inclure la variable dans vars/main.yaml
      lineinfile:
        path: "vars/main.yaml"
        line: "gateway_variable: '{{ gateway_variable }}'"
        create: yes

    - name: Utiliser la variable dans une autre tâche
      debug:
        msg: "La gateway est {{ gateway_variable }}"





Créez le fichier vars/main.yaml comme indiqué précédemment.
Intégrez la commande podman network inspect podman | jq -r '.[0].subnets[0].gateway' dans votre playbook pour récupérer la sortie et l'attribuer à une variable.
Voici comment vous pouvez modifier votre playbook :

yaml
Copy code
---
- name: Exemple de playbook Ansible
  hosts: votre_hôte
  tasks:
    - name: Exécuter la commande shell et récupérer la sortie
      command: "podman network inspect podman | jq -r '.[0].subnets[0].gateway'"
      register: resultat_commande

    - name: Inclure la variable dans vars/main.yaml
      lineinfile:
        path: "vars/main.yaml"
        line: "gateway_variable: '{{ resultat_commande.stdout }}'"
        create: yes

    - name: Utiliser la variable dans une autre tâche
      debug:
        msg: "La gateway est {{ gateway_variable }}"
Assurez-vous que votre rôle Ansible est bien configuré, et remplacez "votre_hôte" par le nom de votre hôte ou le groupe d'hôtes ciblé.

Cette séquence de tâches exécutera la commande shell, enregistrera la sortie dans la variable resultat_commande, puis écrira cette valeur dans le fichier vars/main.yaml. Vous pourrez ensuite utiliser la variable gateway_variable dans d'autres tâches de votre playbook.







pour définir une variable dans le fichier vars/main.yaml en évaluant une commande shell, vous pouvez utiliser le module command pour exécuter la commande shell lors de la lecture des variables. Voici comment vous pouvez le faire :

Créez un fichier vars/main.yaml dans votre rôle Ansible.
Utilisez le module command dans votre playbook pour exécuter la commande shell et stocker le résultat dans une variable.
Utilisez cette variable dans votre fichier vars/main.yaml.
Voici un exemple de structure de répertoire mise à jour :

css
Copy code
roles/
└── votre_role/
    ├── tasks/
    │   └── main.yaml
    ├── vars/
    │   └── main.yaml
    └── ...
Contenu du fichier vars/main.yaml :

yaml
Copy code
---
resultat_commande_variable: "{{ lookup('pipe', 'votre_commande_shell') }}"
Ensuite, vous pouvez utiliser cette variable dans votre playbook comme ceci :

yaml
Copy code
---
- name: Exemple de playbook Ansible
  hosts: votre_hôte
  tasks:
    - name: Définir la variable en évaluant une commande shell
      command: "echo 'votre_commande_shell'"
      register: resultat_commande

    - name: Inclure la variable dans vars/main.yaml
      lineinfile:
        path: "vars/main.yaml"
        line: "resultat_commande_variable: '{{ resultat_commande.stdout }}'"
        create: yes

    - name: Utiliser la variable dans une autre tâche
      debug:
        msg: "Le résultat de la commande est {{ resultat_commande_variable }}"

Assurez-vous de remplacer votre_hôte par le nom de votre hôte ou le groupe d'hôtes ciblé, et votre_commande_shell par la commande shell que vous souhaitez exécuter. Cette méthode écrira le résultat de la commande dans le fichier vars/main.yaml, le rendant disponible pour l'utilisation dans d'autres tâches.












---
volumes:
  semaphore-mysql:
    driver: local
services:
  mysql:
    image: mysql:8.0
    hostname: mysql
    volumes:
      - semaphore-mysql:/var/lib/mysql
    environment:
      - MYSQL_RANDOM_ROOT_PASSWORD=yes
      - MYSQL_DATABASE=semaphore
      - MYSQL_USER=semaphore
      - MYSQL_PASSWORD=secret-password  # change!
    restart: unless-stopped
  semaphore:
    container_name: ansiblesemaphore
    image: semaphoreui/semaphore:v2.9.45
    user: "${UID}:${GID}"
    ports:
      - 3000:3000
    environment:
      - SEMAPHORE_DB_USER=semaphore
      - SEMAPHORE_DB_PASS=secret-password  # change!
      - SEMAPHORE_DB_HOST=mysql
      - SEMAPHORE_DB_PORT=3306
      - SEMAPHORE_DB_DIALECT=mysql
      - SEMAPHORE_DB=semaphore
      - SEMAPHORE_PLAYBOOK_PATH=/tmp/semaphore/
      - SEMAPHORE_ADMIN_PASSWORD=secret-admin-password  # change!
      - SEMAPHORE_ADMIN_NAME=admin
      - SEMAPHORE_ADMIN_EMAIL=admin@localhost
      - SEMAPHORE_ADMIN=admin
      - SEMAPHORE_ACCESS_KEY_ENCRYPTION=  # add to your access key encryption !
      - ANSIBLE_HOST_KEY_CHECKING=false  # (optional) change to true if you want to enable host key checking
    volumes:
      - ./inventory/:/inventory:ro
      - ./authorized-keys/:/authorized-keys:ro
      - ./config/:/etc/semaphore:rw
    restart: unless-stopped
    depends_on:
      - mysql



















#!/bin/bash

# Variable KIND_CONTAINER
KIND_CONTAINER="--publish=127.0.0.1:44605:6443/tcp,"

# Extraire l'adresse IP et le port de KIND_CONTAINER
IP_PORT=$(echo $KIND_CONTAINER | sed -n 's/.*--publish=\([^:]*\):\(.*\):6443\/tcp.*/\1:\2/p')
SERVER_URL="https://${IP_PORT}"

# Mettre à jour le fichier .kube/config
sed -i "s#\(server: https://\)[:0-9]\+#\1${IP_PORT}#" ~/.kube/config

echo "Fichier .kube/config mis à jour avec :"
echo "server: $SERVER_URL"





Lorsque vous utilisez Kind avec Podman en mode rootless, la création d'un service de type LoadBalancer peut poser des problèmes, car les solutions de LoadBalancer standard peuvent ne pas être directement compatibles avec Podman en mode rootless.

Cependant, une alternative est d'utiliser un service de type NodePort. Un service de type NodePort expose votre service sur un port au niveau de chaque nœud du cluster. Vous pouvez ensuite accéder à votre service depuis le host en utilisant l'adresse IP du nœud et le port NodePort.

Voici comment vous pouvez configurer un service de type NodePort :

Créez un fichier YAML pour le Service, par exemple, service-definition.yaml:

yaml
Copy code
apiVersion: v1
kind: Service
metadata:
  name: myservice
spec:
  selector:
    app: mypod
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: NodePort
Créez le Service dans votre cluster Kind :

bash
Copy code
kubectl apply -f service-definition.yaml
Obtenez le port NodePort assigné :

bash
Copy code
kubectl get svc myservice
Vous verrez un port numérique sous la colonne "PORT(S)".

Obtenez l'adresse IP du nœud du cluster :

bash
Copy code
kubectl get nodes -o=jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}'
Accédez à votre service depuis le host en utilisant l'adresse IP du nœud et le port NodePort :

bash
Copy code
curl -v telnet://<IP-du-noeud>:<port-NodePort>
Assurez-vous de remplacer <IP-du-noeud> par l'adresse IP du nœud obtenue à l'étape 4 et <port-NodePort> par le port NodePort obtenu à l'étape 3.

Cela devrait vous permettre d'accéder à votre service depuis le host en utilisant l'adresse IP du nœud et le port NodePort.






Exemple d'exposition de port dans une définition de Pod YAML :

apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mycontainer
    image: myimage
    ports:
    - containerPort: 8080

Vérifiez l'IP du conteneur :
Obtenez l'adresse IP du conteneur en utilisant la commande podman pod inspect ou podman inspect.

Exemple :
podman inspect -f "{{.NetworkSettings.IPAddress}}" <container-id>

ip addr show cni-podman0

iptables -L -n

iptables -P OUTPUT ACCEPT


curl -v telnet://<IP-du-conteneur>:<PORT>



apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mycontainer
    image: your-image
    ports:
    - containerPort: 8080


apiVersion: v1
kind: Service
metadata:
  name: myservice
spec:
  selector:
    app: mypod
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP



kubectl get pod mypod -o=jsonpath='{.status.podIP}'


curl -v telnet://<IP-du-conteneur>:<PORT-du-Service>



# Exemple : Créez un ConfigMap avec les serveurs DNS
kubectl create configmap kube-dns --from-file=/etc/resolv.conf

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
spec:
  rules:
  - host: example.com  # Remplacez par le nom de votre hôte
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service  # Remplacez par le nom de votre service
            port:
              number: 80

