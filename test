https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/building_running_and_managing_containers/index

https://developers.redhat.com/blog/2020/09/25/rootless-containers-with-podman-the-basics#example__using_rootless_containers

https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html-single/managing_containers/index#set_up_for_rootless_containers

https://github.com/containers/podman/blob/main/docs/tutorials/rootless_tutorial.md

https://docs.oracle.com/en/operating-systems/oracle-linux/podman/podman-ConfiguringStorageforPodman.html#podman-install-storage

https://github.com/containers/podman/blob/main/docs/tutorials/rootless_tutorial.md





export KIND_IGNORED_LOGS=".*detected cgroup v1.*"
kind create cluster






Pour configurer Podman en mode rootless sous RHEL 8 et définir un fichier storage.conf avec les bonnes options et bonnes pratiques, vous pouvez suivre les étapes ci-dessous :

Assurez-vous que les packages fuse-overlayfs et slirp4netns sont installés. Vous pouvez les installer avec la commande suivante :
bash
Copy code
sudo dnf install fuse-overlayfs slirp4netns
Créez un répertoire pour stocker les fichiers de configuration de Podman si vous n'en avez pas déjà un. Par exemple :
bash
Copy code
mkdir -p $HOME/.config/containers
Créez un fichier de configuration storage.conf dans ce répertoire. Vous pouvez utiliser un éditeur de texte de votre choix, par exemple :
bash
Copy code
nano $HOME/.config/containers/storage.conf
Dans le fichier storage.conf, vous pouvez spécifier les options de stockage. Voici un exemple de configuration avec des options courantes :
ini
Copy code
# storage.conf for rootless Podman

[storage]
  driver = "overlay"
  runroot = "$HOME/.local/share/containers/storage/run"
  graphroot = "$HOME/.local/share/containers/storage"
  root = "$HOME/.local/share/containers/storage/rootfs"
  mounts = "$HOME/.local/share/containers/storage/mount"
  graphdriver = "overlay"
  runroot = "$HOME/.local/share/containers/storage/run"
  graphroot = "$HOME/.local/share/containers/storage"
  state = "$HOME/.local/share/containers/storage/libpod"
  tmpdir = "/run/user/$(id -u)"

[storage.options]
  Overlay.mount_program = "fuse-overlayfs"
  Overlay.mountopt = "nodev,metacopy=on"
  Overlay.override_kernel_check = "true"
  VFS.mount_program = "slirp4netns"
  VFS.mountopt = "context=system_u:object_r:container_file_t:s0:c5,c255"

[storage.cleanup]
  age = "168h"
  interval = "24h"
N'oubliez pas d'adapter les chemins (comme $HOME/.local/share/containers/storage) à votre configuration personnelle si nécessaire. Les options spécifiques à overlay et slirp4netns sont incluses pour une meilleure compatibilité avec le mode rootless. Les valeurs par défaut peuvent également fonctionner pour de nombreuses situations.

Enregistrez et fermez le fichier storage.conf.

Vous pouvez maintenant utiliser Podman en mode rootless avec cette configuration. Assurez-vous que votre utilisateur a les bonnes autorisations pour le répertoire de stockage que vous avez défini dans storage.conf.

Assurez-vous que Podman est correctement configuré en rootless pour votre utilisateur. Vous pouvez tester en exécutant la commande podman info pour vérifier que les informations de stockage reflètent la configuration que vous avez définie dans le fichier storage.conf.




User
la partie SELinux est activé et enforcé , cela poserait des problèmes ?
ChatGPT
Si SELinux est activé et enforcé sur votre système RHEL 8, cela peut en effet poser des problèmes lors de l'utilisation de Podman en mode rootless, en particulier si les étiquettes SELinux ne sont pas correctement configurées. Pour résoudre ces problèmes, vous devez tenir compte de SELinux lors de la configuration de Podman.

Voici quelques étapes pour vous aider à configurer Podman en mode rootless tout en tenant compte de SELinux :

Assurez-vous que les packages fuse-overlayfs et slirp4netns sont installés, comme mentionné précédemment.

Créez votre fichier storage.conf comme indiqué dans la réponse précédente, mais également assurez-vous que les chemins que vous spécifiez dans storage.conf sont conformes à la politique SELinux. Par exemple, si vous utilisez des répertoires sous votre répertoire personnel, assurez-vous qu'ils sont correctement étiquetés.

Assurez-vous que les fichiers et répertoires utilisés par Podman ont les étiquettes SELinux appropriées. Vous pouvez utiliser la commande chcon pour définir ces étiquettes si nécessaire. Par exemple :

bash
Copy code
chcon -Rt svirt_sandbox_file_t $HOME/.local/share/containers
Cela définira les étiquettes SELinux appropriées pour les fichiers stockés dans le répertoire $HOME/.local/share/containers. Assurez-vous d'ajuster cette commande en fonction de votre propre structure de répertoires.

Si vous continuez à rencontrer des problèmes SELinux, envisagez de consulter les journaux SELinux pour des messages d'audit qui peuvent vous aider à comprendre quelles politiques sont enfreintes. Vous pouvez utiliser la commande ausearch ou consulter les journaux SELinux pour des informations détaillées.

Vous pouvez également envisager d'utiliser des outils SELinux tels que setsebool pour définir des options SELinux spécifiques qui peuvent être nécessaires pour votre configuration Podman.

En respectant ces étapes et en veillant à ce que les étiquettes SELinux soient correctement configurées pour les fichiers et répertoires utilisés par Podman, vous devriez pouvoir exécuter Podman en mode rootless sur un système avec SELinux activé et enforcé. Cependant, il est important de noter que la configuration SELinux peut être complexe, et vous devrez peut-être travailler en étroite collaboration avec l'administrateur SELinux de votre système ou rechercher des conseils spécifiques à votre environnement pour résoudre tout problème SELinux spécifique que vous pourriez rencontrer.




User
parfait je vais m'appuyer sur toutes ces informations pour tester tout cela merci
ChatGPT
De rien ! Je suis heureux d'avoir pu vous aider. Si vous avez d'autres questions ou avez besoin de plus d'assistance lors de vos tests, n'hésitez pas à demander. Bonne chance avec votre configuration de Podman en mode rootless sous SELinux, et n'hésitez pas à revenir si vous avez besoin de plus d'aide à l'avenir.




User
juste une dernière question je n'ai pas trouvé dans mes recherches ... quand je fais un podman build --no-cache (ou docker ou buildah qui est la référence sous rhel 8), j'ai remarqué qu'il y a toujours des layers non purgé et recréé à chaque fois ... même si on fait un docker system prune -f ou podman system reset, les layers (pas de noms ni de labels...) persistent quand on fait docker images
ChatGPT
Lorsque vous exécutez docker build, podman build ou buildah bud avec l'option --no-cache, cela signifie que l'image sera reconstruite sans utiliser le cache existant. Cependant, cela ne signifie pas nécessairement que les couches de l'image précédente seront supprimées automatiquement après la construction. Vous devez supprimer l'image précédente manuellement si vous souhaitez libérer de l'espace disque.

Voici comment vous pouvez supprimer l'image précédente après avoir reconstruit avec --no-cache :

Pour Docker :

bash
Copy code
docker rmi <nom_de_l'image_précédente>
Pour Podman :

bash
Copy code
podman rmi <nom_de_l'image_précédente>
Pour Buildah :

bash
Copy code
buildah rmi <nom_de_l'image_précédente>
Après avoir supprimé l'image précédente, vous devriez constater que les couches inutilisées sont supprimées, libérant ainsi de l'espace disque. Le fait de simplement exécuter docker system prune -f ou podman system reset ne supprimera pas automatiquement les couches d'images qui ne sont plus référencées par aucune image.

Assurez-vous de remplacer <nom_de_l'image_précédente> par le nom ou l'ID de l'image que vous souhaitez supprimer. Une fois l'image précédente supprimée, vous devriez voir une utilisation de l'espace disque réduite.



















Pour atteindre un serveur SSH via HTTPS sur le port 443, vous pouvez utiliser un outil appelé SSH over HTTPS (ou SSH over SSL), qui encapsule le trafic SSH dans une connexion HTTPS, ce qui peut être utile dans des environnements où le port 22 est bloqué. Voici comment vous pouvez mettre en place cette configuration :

Configuration du serveur SSH :

Assurez-vous que votre serveur SSH (OpenSSH) est configuré pour écouter sur un port différent (par exemple, 2222) dans le fichier de configuration /etc/ssh/sshd_config. Vous pouvez spécifier le port en utilisant l'option Port. Assurez-vous que le serveur SSH est configuré pour autoriser uniquement l'authentification par clé.
plaintext
Copy code
Port 2222
PasswordAuthentication no
Redémarrez le service SSH pour appliquer la nouvelle configuration.
bash
Copy code
systemctl restart sshd
Mise en place d'un tunnel HTTPS :

Pour encapsuler le trafic SSH dans HTTPS, vous pouvez utiliser un outil comme stunnel (Secure Tunnel). Installez stunnel sur votre serveur et configurez-le pour écouter sur le port 443 et rediriger le trafic vers le port SSH.

Voici un exemple de configuration pour stunnel dans /etc/stunnel/stunnel.conf :

plaintext
Copy code
[ssh-https]
accept = 443
connect = 127.0.0.1:2222
Cette configuration écoute sur le port 443 en HTTPS et redirige le trafic vers le port SSH (2222) en clair sur la même machine.

Redémarrez le service stunnel pour appliquer la configuration.
bash
Copy code
systemctl restart stunnel
Accès au serveur via SSH over HTTPS :

Maintenant, vous pouvez vous connecter à votre serveur en utilisant HTTPS sur le port 443. Par exemple, avec curl :
bash
Copy code
curl https://votre-serveur:443 -v --insecure
Cela encapsule le trafic SSH dans une connexion HTTPS sécurisée.

Assurez-vous de configurer correctement la sécurité HTTPS, y compris l'utilisation de certificats SSL valides, pour protéger votre connexion. Cela permettra d'atteindre votre serveur SSH via HTTPS sur le port 443, même si le port SSH standard est bloqué.




User
mon serveur openssh est déployé dans un cluster kubernetes et utilise le port 2222... il faudrait donc que j'installe dans la même image docker stunne1 et créer une ingress rule (nginx) pointant sur le service 443
ChatGPT
Si votre serveur OpenSSH est déployé dans un cluster Kubernetes et utilise le port 2222, et que vous souhaitez encapsuler le trafic SSH dans une connexion HTTPS en utilisant stunnel, vous pouvez suivre les étapes suivantes :

Créez une image Docker avec stunnel :

Vous devrez créer une image Docker personnalisée qui inclut OpenSSH et stunnel. Vous pouvez utiliser un fichier Dockerfile pour construire cette image. Voici un exemple minimal :
Dockerfile
Copy code
FROM centos:7

# Installez OpenSSH et stunnel
RUN yum -y install openssh-server stunnel

# Copiez votre configuration SSH et stunnel dans l'image
COPY sshd_config /etc/ssh/sshd_config
COPY stunnel.conf /etc/stunnel/stunnel.conf

# Exposez le port SSH
EXPOSE 2222

# Commande d'entrée
CMD ["/usr/sbin/sshd", "-D"]
Assurez-vous d'ajouter votre fichier de configuration SSH (sshd_config) et de configuration stunnel (stunnel.conf) dans le même répertoire que votre Dockerfile. Assurez-vous également que votre image Docker inclut un certificat SSL valide pour stunnel.

Construisez l'image Docker :

Utilisez la commande docker build pour construire votre image Docker personnalisée.
Déployez l'image dans Kubernetes :

Utilisez Kubernetes pour déployer cette image dans votre cluster. Vous pouvez créer une ressource Deployment ou StatefulSet, selon vos besoins.
Créez une Ingress pour HTTPS :

Créez une règle Ingress pour exposer le service stunnel via HTTPS sur le port 443. Utilisez Nginx Ingress Controller ou un autre contrôleur Ingress compatible avec votre cluster Kubernetes. Par exemple :
yaml
Copy code
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ssh-over-https
spec:
  rules:
  - host: ssh.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: stunnel-service
            port:
              number: 443
Assurez-vous de remplacer ssh.example.com par le nom de domaine ou l'adresse IP que vous souhaitez utiliser pour accéder au service SSH via HTTPS.

Appliquez la configuration de l'Ingress :

Utilisez kubectl apply pour appliquer la configuration de l'Ingress à votre cluster Kubernetes.
Une fois ces étapes terminées, vous pourrez atteindre votre serveur SSH via HTTPS sur le port 443 en utilisant l'Ingress que vous avez configurée. Le trafic SSH sera encapsulé dans une connexion HTTPS sécurisée grâce à stunnel. Assurez-vous de gérer correctement la sécurité, notamment en obtenant un certificat SSL valide pour le service stunnel.




User
sur un poste client, pour se connecter à se serveur via https:443 quel serait la configuration (.ssh/config)
ChatGPT
Pour vous connecter à votre serveur via HTTPS (port 443) à l'aide de la configuration SSH dans le fichier ~/.ssh/config de votre poste client, vous pouvez ajouter une entrée spécifique pour ce serveur. Voici un exemple de configuration :

plaintext
Copy code
Host mon-serveur-https
    HostName ssh.example.com  # Remplacez par votre nom de domaine ou adresse IP
    Port 443
    User votre_utilisateur_ssh  # Remplacez par votre nom d'utilisateur SSH
    ProxyCommand /usr/bin/stunnel4 mon-serveur-https:443  # Assurez-vous que stunnel est installé
    IdentityFile ~/.ssh/votre_cle_privee  # Remplacez par le chemin de votre clé privée
Assurez-vous de personnaliser cette configuration en remplaçant les valeurs par les informations spécifiques à votre configuration. Voici ce que fait chaque ligne :

Host mon-serveur-https: Il s'agit d'un alias que vous pouvez utiliser pour vous connecter au serveur via SSH en utilisant ce nom convivial. Remplacez "mon-serveur-https" par le nom que vous souhaitez.

HostName ssh.example.com: Remplacez "ssh.example.com" par le nom de domaine ou l'adresse IP de votre serveur.

Port 443: Spécifie que la connexion SSH doit utiliser le port 443 au lieu du port SSH standard (22).

User votre_utilisateur_ssh: Remplacez "votre_utilisateur_ssh" par votre nom d'utilisateur SSH.

ProxyCommand /usr/bin/stunnel4 mon-serveur-https:443: Cette ligne indique à SSH d'utiliser stunnel pour encapsuler le trafic SSH dans une connexion HTTPS vers le serveur. Assurez-vous que stunnel est installé sur votre poste client et que la configuration d'encapsulation est correcte.

IdentityFile ~/.ssh/votre_cle_privee: Spécifie le chemin de votre clé privée SSH. Assurez-vous que le chemin pointe vers votre clé privée.

Une fois que vous avez ajouté cette configuration dans votre fichier ~/.ssh/config, vous pouvez vous connecter au serveur en utilisant l'alias que vous avez défini. Par exemple :

bash
Copy code
ssh mon-serveur-https
Cela utilisera la configuration que vous avez spécifiée pour se connecter au serveur via HTTPS sur le port 443








Pour configurer Podman en tant que service systemd sous RHEL 8 avec le runtime CRUN, le réseau CNI, etc., tout en permettant aux utilisateurs d'utiliser Podman en mode rootless dans leurs profils respectifs, vous devrez effectuer plusieurs étapes de configuration. Voici un guide étape par étape pour accomplir cela :

Installation de Podman et des dépendances :
Assurez-vous d'installer Podman, CRUN, et les composants CNI nécessaires sur votre système. Vous pouvez le faire à l'aide du gestionnaire de paquets dnf :

bash
Copy code
sudo dnf install -y podman crun
Configuration du service systemd pour Podman en mode système :
Créez un fichier de service systemd pour Podman, par exemple /etc/systemd/system/podman.service, avec le contenu suivant :

ini
Copy code
[Unit]
Description=Podman service
Documentation=man:podman-system-service(1)

[Service]
ExecStart=/usr/bin/podman system service --time=0
Restart=always
TimeoutStopSec=0
KillMode=none
RestartSec=10s

[Install]
WantedBy=multi-user.target
Assurez-vous d'ajuster le chemin de l'exécutable podman en fonction de votre installation.

Activer et démarrer le service systemd :

bash
Copy code
sudo systemctl enable podman.service
sudo systemctl start podman.service
Configuration de Podman en mode rootless :
Chaque utilisateur qui souhaite utiliser Podman en mode rootless doit effectuer les étapes suivantes :

a. Créez un fichier ~/.config/containers/containers.conf s'il n'existe pas et ajoutez la configuration suivante :

yaml
Copy code
runtime = "crun"
cni = "/path/to/cni-plugins-directory" # Remplacez par le chemin du répertoire CNI
b. Assurez-vous que le répertoire /path/to/cni-plugins-directory existe et contient les plugins CNI requis. Vous pouvez télécharger ces plugins depuis le référentiel CNI officiel (https://github.com/containernetworking/plugins).

c. Configurez les variables d'environnement pour Podman dans le profil de l'utilisateur, par exemple, dans ~/.bashrc ou ~/.zshrc :

bash
Copy code
export PATH=$HOME/.local/bin:$PATH
export XDG_RUNTIME_DIR=/run/user/$(id -u)
Ces variables d'environnement garantissent que les binaires et les sockets de Podman en mode rootless sont correctement configurés.

Redémarrez la session de l'utilisateur ou rechargez le profil :

bash
Copy code
source ~/.bashrc  # ou source ~/.zshrc
L'utilisateur devrait maintenant pouvoir utiliser Podman en mode rootless avec la configuration spécifiée.

Assurez-vous d'adapter ces étapes en fonction de vos besoins spécifiques et de la structure de votre système. Ce guide fournit une base pour configurer Podman en tant que service systemd en mode système et permettre aux utilisateurs d'utiliser Podman en mode rootless dans leurs profils respectifs.


























Si vous avez pu résoudre le problème en ajoutant l'option --network=true lors de la création du conteneur avec Podman, cela indique que SELinux restreint l'accès réseau des conteneurs au système hôte par défaut.

Pour permettre aux conteneurs Podman de communiquer avec le réseau de l'hôte en utilisant SELinux, vous pouvez ajouter une règle personnalisée. Voici comment vous pouvez créer une règle personnalisée pour autoriser la communication réseau des conteneurs :

Identifiez le port que vous souhaitez autoriser pour la communication du conteneur. Par exemple, si votre proxy utilise le port 3128, vous pouvez autoriser ce port.

Utilisez la commande audit2allow pour générer une règle SELinux personnalisée basée sur les journaux de SELinux. Exécutez la commande suivante après avoir effectué une opération de conteneur qui a été refusée par SELinux (par exemple, après avoir exécuté le conteneur avec l'option --network=true) :

bash
Copy code
audit2allow -a
Cela affichera les règles qui ont été refusées. Vous pouvez les copier dans un fichier.

Créez un fichier de règles personnalisées, par exemple custom-containers.te, et collez-y les règles générées.

Utilisez checkmodule pour compiler les règles :

bash
Copy code
checkmodule -M -m -o custom-containers.mod custom-containers.te
Utilisez semodule_package pour générer un module SELinux :

bash
Copy code
semodule_package -o custom-containers.pp -m custom-containers.mod
Utilisez semodule pour installer le module SELinux :

bash
Copy code
semodule -i custom-containers.pp
Redémarrez le conteneur pour que les nouvelles règles SELinux prennent effet.

Cela devrait autoriser la communication réseau du conteneur avec le port spécifié. Assurez-vous de personnaliser les règles en fonction de vos besoins spécifiques.

N'oubliez pas que l'ajout de règles SELinux personnalisées peut potentiellement introduire des vulnérabilités de sécurité si elles sont mal configurées, alors assurez-vous de comprendre les implications de sécurité avant d'appliquer des règles personnalisées.





Il semble que vous ayez des problèmes pour faire fonctionner Podman avec un proxy sous RHEL 8 pour la construction d'images, malgré la définition des variables d'environnement http_proxy, https_proxy, no_proxy, etc. pour votre proxy. Voici quelques étapes que vous pouvez suivre pour résoudre ce problème :

Assurez-vous que Podman est configuré pour utiliser le proxy du système :
Vous pouvez vérifier la configuration de Podman en utilisant la commande suivante :

bash
Copy code
podman system info
Assurez-vous que l'option "HTTP Proxy" pointe vers votre proxy local ou vers l'adresse appropriée. Si ce n'est pas le cas, vous pouvez configurer Podman pour utiliser le proxy du système en ajoutant la ligne suivante dans le fichier de configuration de Podman, généralement situé à /etc/containers/containers.conf :

ini
Copy code
[proxies]
"default" = "system"
Cela devrait permettre à Podman d'utiliser le proxy du système défini dans les variables d'environnement.

Redémarrez le service Podman :
Après avoir modifié la configuration de Podman, redémarrez le service Podman pour que les modifications prennent effet :

bash
Copy code
systemctl restart podman
Assurez-vous que les variables d'environnement du proxy sont correctement définies :
Comme vous l'avez mentionné, assurez-vous que les variables d'environnement http_proxy, https_proxy, no_proxy, etc. sont correctement définies avec les valeurs appropriées. Vous pouvez les vérifier en utilisant la commande echo :

bash
Copy code
echo $http_proxy
echo $https_proxy
echo $no_proxy
Testez la connectivité au proxy :
Assurez-vous que votre système est capable de se connecter au proxy en utilisant les variables d'environnement définies. Vous pouvez utiliser la commande curl pour effectuer un test de connexion :

bash
Copy code
curl http://example.com --proxy $http_proxy
Assurez-vous que les fichiers PAC sont correctement configurés :
Vérifiez que les fichiers de configuration Proxy Auto-Configuration (PAC) sont correctement configurés sur votre système et qu'ils sont accessibles. Podman utilisera ces fichiers s'ils sont correctement configurés.

Si, après avoir suivi ces étapes, vous rencontrez toujours des problèmes pour construire des images avec Podman via le proxy, vous pouvez également consulter les journaux de Podman (journalctl -u podman.service) pour des informations plus détaillées sur les erreurs rencontrées.

Enfin, assurez-vous que vous avez les droits d'accès appropriés pour utiliser le proxy, car certaines politiques d'entreprise peuvent restreindre l'accès aux proxies. Si vous rencontrez des problèmes persistants, il peut être utile de travailler en étroite collaboration avec le service informatique de votre entreprise pour résoudre ces problèmes.
