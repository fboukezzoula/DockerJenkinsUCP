---
volumes:
  semaphore-mysql:
    driver: local
services:
  mysql:
    image: mysql:8.0
    hostname: mysql
    volumes:
      - semaphore-mysql:/var/lib/mysql
    environment:
      - MYSQL_RANDOM_ROOT_PASSWORD=yes
      - MYSQL_DATABASE=semaphore
      - MYSQL_USER=semaphore
      - MYSQL_PASSWORD=secret-password  # change!
    restart: unless-stopped
  semaphore:
    container_name: ansiblesemaphore
    image: semaphoreui/semaphore:v2.9.45
    user: "${UID}:${GID}"
    ports:
      - 3000:3000
    environment:
      - SEMAPHORE_DB_USER=semaphore
      - SEMAPHORE_DB_PASS=secret-password  # change!
      - SEMAPHORE_DB_HOST=mysql
      - SEMAPHORE_DB_PORT=3306
      - SEMAPHORE_DB_DIALECT=mysql
      - SEMAPHORE_DB=semaphore
      - SEMAPHORE_PLAYBOOK_PATH=/tmp/semaphore/
      - SEMAPHORE_ADMIN_PASSWORD=secret-admin-password  # change!
      - SEMAPHORE_ADMIN_NAME=admin
      - SEMAPHORE_ADMIN_EMAIL=admin@localhost
      - SEMAPHORE_ADMIN=admin
      - SEMAPHORE_ACCESS_KEY_ENCRYPTION=  # add to your access key encryption !
      - ANSIBLE_HOST_KEY_CHECKING=false  # (optional) change to true if you want to enable host key checking
    volumes:
      - ./inventory/:/inventory:ro
      - ./authorized-keys/:/authorized-keys:ro
      - ./config/:/etc/semaphore:rw
    restart: unless-stopped
    depends_on:
      - mysql



















#!/bin/bash

# Variable KIND_CONTAINER
KIND_CONTAINER="--publish=127.0.0.1:44605:6443/tcp,"

# Extraire l'adresse IP et le port de KIND_CONTAINER
IP_PORT=$(echo $KIND_CONTAINER | sed -n 's/.*--publish=\([^:]*\):\(.*\):6443\/tcp.*/\1:\2/p')
SERVER_URL="https://${IP_PORT}"

# Mettre à jour le fichier .kube/config
sed -i "s#\(server: https://\)[:0-9]\+#\1${IP_PORT}#" ~/.kube/config

echo "Fichier .kube/config mis à jour avec :"
echo "server: $SERVER_URL"





Lorsque vous utilisez Kind avec Podman en mode rootless, la création d'un service de type LoadBalancer peut poser des problèmes, car les solutions de LoadBalancer standard peuvent ne pas être directement compatibles avec Podman en mode rootless.

Cependant, une alternative est d'utiliser un service de type NodePort. Un service de type NodePort expose votre service sur un port au niveau de chaque nœud du cluster. Vous pouvez ensuite accéder à votre service depuis le host en utilisant l'adresse IP du nœud et le port NodePort.

Voici comment vous pouvez configurer un service de type NodePort :

Créez un fichier YAML pour le Service, par exemple, service-definition.yaml:

yaml
Copy code
apiVersion: v1
kind: Service
metadata:
  name: myservice
spec:
  selector:
    app: mypod
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: NodePort
Créez le Service dans votre cluster Kind :

bash
Copy code
kubectl apply -f service-definition.yaml
Obtenez le port NodePort assigné :

bash
Copy code
kubectl get svc myservice
Vous verrez un port numérique sous la colonne "PORT(S)".

Obtenez l'adresse IP du nœud du cluster :

bash
Copy code
kubectl get nodes -o=jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}'
Accédez à votre service depuis le host en utilisant l'adresse IP du nœud et le port NodePort :

bash
Copy code
curl -v telnet://<IP-du-noeud>:<port-NodePort>
Assurez-vous de remplacer <IP-du-noeud> par l'adresse IP du nœud obtenue à l'étape 4 et <port-NodePort> par le port NodePort obtenu à l'étape 3.

Cela devrait vous permettre d'accéder à votre service depuis le host en utilisant l'adresse IP du nœud et le port NodePort.






Exemple d'exposition de port dans une définition de Pod YAML :

apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mycontainer
    image: myimage
    ports:
    - containerPort: 8080

Vérifiez l'IP du conteneur :
Obtenez l'adresse IP du conteneur en utilisant la commande podman pod inspect ou podman inspect.

Exemple :
podman inspect -f "{{.NetworkSettings.IPAddress}}" <container-id>

ip addr show cni-podman0

iptables -L -n

iptables -P OUTPUT ACCEPT


curl -v telnet://<IP-du-conteneur>:<PORT>



apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mycontainer
    image: your-image
    ports:
    - containerPort: 8080


apiVersion: v1
kind: Service
metadata:
  name: myservice
spec:
  selector:
    app: mypod
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP



kubectl get pod mypod -o=jsonpath='{.status.podIP}'


curl -v telnet://<IP-du-conteneur>:<PORT-du-Service>



# Exemple : Créez un ConfigMap avec les serveurs DNS
kubectl create configmap kube-dns --from-file=/etc/resolv.conf

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
spec:
  rules:
  - host: example.com  # Remplacez par le nom de votre hôte
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service  # Remplacez par le nom de votre service
            port:
              number: 80

