# Installation du module SSHKeyUtils depuis PowerShell Gallery
Install-Module -Name SSHKeyUtils -Scope CurrentUser -Force

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant SSHKeyUtils
$rsaKey = New-SSHKeyRSA -NoPassphrase -KeyLength 4096

# Enregistrer la clé privée dans le fichier
$rsaKey.PrivateKey | Out-File -FilePath $sshKeyFile -Encoding ASCII

Write-Host "La clé SSH a été générée avec succès."






Vous pouvez télécharger la bibliothèque BouncyCastle depuis le site officiel du projet sur GitHub. Voici les étapes pour télécharger et utiliser la bibliothèque BouncyCastle :

Accédez à la page GitHub de BouncyCastle : https://github.com/bcgit/bc-csharp

Cliquez sur le bouton vert "Code" et sélectionnez "Download ZIP" pour télécharger l'archive ZIP contenant le code source de BouncyCastle.

Extrayez le contenu de l'archive ZIP téléchargée sur votre ordinateur.

Dans le dossier extrait, accédez au sous-dossier bc-csharp\BouncyCastle.Crypto\bin\Release\net471 (ou à un autre sous-dossier approprié en fonction de votre environnement).

Dans ce sous-dossier, vous trouverez le fichier BouncyCastle.OpenSsl.dll. Copiez ce fichier dans le chemin C:\chemin\vers\ spécifié dans le script PowerShell.

Une fois que vous avez copié le fichier BouncyCastle.OpenSsl.dll dans le bon chemin, vous pouvez exécuter le script PowerShell que je vous ai fourni précédemment.

Veuillez noter que les chemins spécifiés (C:\chemin\vers\BouncyCastle.Crypto.dll et C:\chemin\vers\BouncyCastle.OpenSsl.dll) dans le script doivent être modifiés en fonction de l'emplacement réel où vous avez copié les fichiers DLL.

J'espère que cela vous aide. Si vous avez d'autres questions, n'hésitez pas à demander.



Add-Type -Path "C:\chemin\vers\BouncyCastle.Crypto.dll"
Add-Type -Path "C:\chemin\vers\BouncyCastle.OpenSsl.dll"

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant BouncyCastle
$keyGen = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$keyGen.Init((New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096))

$keyPair = $keyGen.GenerateKeyPair()

$privateKey = [Org.BouncyCastle.OpenSsl.PemWriter]::ToPemString($keyPair.Private)
$publicKey = [Org.BouncyCastle.OpenSsl.PemWriter]::ToPemString($keyPair.Public)

Set-Content -Path $sshKeyFile -Value $privateKey

Write-Host "La clé SSH a été générée avec succès."




$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant le module OpenSSH
$null = New-Item -ItemType File -Path "$sshKeyPath\config" -Force

$sshKeyGenCommand = "ssh-keygen -t rsa -b 4096 -N '' -f $sshKeyFile"
$null = Invoke-Expression -Command $sshKeyGenCommand

Write-Host "La clé SSH a été générée avec succès."




$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant ssh-keygen
$sshKeyGenArgs = "-t rsa -b 4096 -f $sshKeyFile"
Start-Process -FilePath ssh-keygen -ArgumentList $sshKeyGenArgs -NoNewWindow -Wait

Write-Host "La clé SSH a été générée avec succès."







$sshKeygenCommand = "ssh-keygen -t rsa -b 4096 -N '' -f $sshKeyFile"
$null = Invoke-Expression -Command $sshKeygenCommand







Add-Type -Path "C:\chemin\vers\BouncyCastle.Crypto.dll"

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

$keyGen = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$keyGen.Init((New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096))

$keyPair = $keyGen.GenerateKeyPair()
$privateKeyInfo = [Org.BouncyCastle.Security.PrivateKeyInfo]::Factory.CreatePrivateKeyInfo($keyPair.Private)
$privateKeyContent = [System.Convert]::ToBase64String($privateKeyInfo.GetEncoded())

Set-Content -Path $sshKeyFile -Value "-----BEGIN OPENSSH PRIVATE KEY-----`n$privateKeyContent`n-----END OPENSSH PRIVATE KEY-----"

Write-Host "La clé SSH a été générée avec succès."








Add-Type -Path "C:\chemin\vers\BouncyCastle.Crypto.dll"

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

$keyGen = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$keyGen.Init((New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096))

$keyPair = $keyGen.GenerateKeyPair()
$privateKeyInfo = [Org.BouncyCastle.OpenSsl.PemWriter]::ToPemObject($keyPair.Private)
$privateKeyContent = [System.Text.Encoding]::ASCII.GetBytes($privateKeyInfo.Content)

Set-Content -Path $sshKeyFile -Value $privateKeyContent -Encoding Byte

Write-Host "La clé SSH a été générée avec succès."






# Installer le module SSH.NET s'il n'est pas déjà installé
if (-not (Get-Module -ListAvailable -Name SSH.NET)) {
    Install-Module -Name SSH.NET -Scope CurrentUser -Force
}

# Importer le module SSH.NET
Import-Module -Name SSH.NET

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant SSH.NET
$rsaKey = [Renci.SshNet.SecurityKeyFactory]::KeyGenerate('RSA', 4096)
$privateKeyContent = [Renci.SshNet.PrivateKeyFile]::new($rsaKey).GetBytes()

Set-Content -Path $sshKeyFile -Value $privateKeyContent -Encoding Byte

Write-Host "La clé SSH a été générée avec succès."






Add-Type -Path "C:\chemin\vers\BouncyCastle.Crypto.dll"

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

$generator = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$parameters = New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096
$generator.Init($parameters)

$keyPair = $generator.GenerateKeyPair()

$privateKey = $keyPair.Private

$privateKeyContent = [Convert]::ToBase64String($privateKey.GetEncoded())

Set-Content -Path $sshKeyFile -Value "-----BEGIN OPENSSH PRIVATE KEY-----`n$privateKeyContent`n-----END OPENSSH PRIVATE KEY-----"

Write-Host "La clé SSH a été générée avec succès."







https://www.powershellgallery.com/packages/SSH/1.0.0


# Importer les modules requis
Add-Type -Path (Join-Path (Get-Package -Name BouncyCastle).Source 'lib\netstandard2.0\BouncyCastle.Crypto.dll')

# Définir les paramètres pour la clé SSH
$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Générer une nouvelle clé SSH RSA sans passphrase
$keyPairGenerator = [BouncyCastle.Crypto.Generators.RsaKeyPairGenerator]::new()
$keyParams = [BouncyCastle.Crypto.KeyGenerationParameters]::new($null, 4096)
$keyPairGenerator.Init($keyParams)
$keyPair = $keyPairGenerator.GenerateKeyPair()

$privateKeyInfo = [BouncyCastle.OpenSsl.PemWriter]::new([System.IO.File]::CreateText($sshKeyFile))
$privateKeyInfo.WriteObject($keyPair.Private)
$privateKeyInfo.Writer.Close()

Write-Host "La clé SSH a été générée avec succès."


# Importer le module SSH.NET
Import-Module -Name SSH.NET

# Définir les paramètres pour la clé SSH
$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant SSH.NET
$rsaKey = [Renci.SshNet.SecurityKeyFactory]::KeyGenerate('RSA', 4096)
$privateKey = [Renci.SshNet.PrivateKeyFile]::Create($sshKeyFile, $rsaKey, '')

Write-Host "La clé SSH a été générée avec succès."




$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant ssh-keygen
$sshKeyGenArgs = "-t rsa -b 4096 -N '' -f $sshKeyFile"
Start-Process -FilePath ssh-keygen -ArgumentList $sshKeyGenArgs -NoNewWindow -Wait

Write-Host "La clé SSH a été générée avec succès."





# Installer le module Posh-SSH s'il n'est pas déjà installé
if (-not (Get-Module -ListAvailable -Name Posh-SSH)) {
    Install-Module -Name Posh-SSH -Force
}

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant Posh-SSH
$rsaKey = New-SSHKey -Path $sshKeyFile -KeyLength 4096

Write-Host "La clé SSH a été générée avec succès."


if (Get-Module -ListAvailable -Name OpenSSH) {
    Write-Host "OpenSSH est installé sur ce système."
}
else {
    Write-Host "OpenSSH n'est pas installé sur ce système."
}


$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant OpenSSH
$sshKeyGenArgs = "-t rsa -b 4096 -N '' -f $sshKeyFile"
& ssh-keygen $sshKeyGenArgs

Write-Host "La clé SSH a été générée avec succès."



@echo off

REM Définition des variables
set "repoUrl=https://github.com/votre-utilisateur/votre-repo.git"
set "targetDirectory=C:\chemin\vers\repertoire-cible"
set "psScript=nom-du-script.ps1"
set "argument=argument-du-script"

REM Vérification si le répertoire cible existe et le supprimer s'il existe
if exist "%targetDirectory%" (
    echo Suppression du répertoire cible existant...
    rmdir /s /q "%targetDirectory%"
)

REM Clonage du dépôt Git
git clone "%repoUrl%" "%targetDirectory%"

REM Vérification si le clonage a réussi
if %errorlevel% neq 0 (
    echo Une erreur est survenue lors du clonage du dépôt Git.
    exit /b %errorlevel%
)

REM Déplacement vers le répertoire cloné
cd "%targetDirectory%"

REM Exécution du script PowerShell avec l'argument spécifié
powershell -ExecutionPolicy Bypass -File "%psScript%" -argument "%argument%"

REM Ouvrir une nouvelle instance de PowerShell dans le répertoire cloné
start powershell -NoExit -Command "cd \"%targetDirectory%\""



@echo off

REM Définition des variables
set "repoUrl=https://github.com/votre-utilisateur/votre-repo.git"
set "targetDirectory=C:\chemin\vers\repertoire-cible"
set "psScript=nom-du-script.ps1"

REM Clonage du dépôt Git
git clone "%repoUrl%" "%targetDirectory%"

REM Vérification si le clonage a réussi
if %errorlevel% neq 0 (
    echo Une erreur est survenue lors du clonage du dépôt Git.
    exit /b %errorlevel%
)

REM Déplacement vers le répertoire cloné
cd "%targetDirectory%"

REM Exécution du script PowerShell
powershell -ExecutionPolicy Bypass -File "%psScript%"






@echo off

REM Définition des variables
set "repoUrl=https://github.com/votre-utilisateur/votre-repo.git"
set "targetDirectory=C:\chemin\vers\repertoire-cible"
set "psScript=nom-du-script.ps1"

REM Clonage du dépôt Git
git clone "%repoUrl%" "%targetDirectory%"

REM Vérification si le clonage a réussi
if %errorlevel% neq 0 (
    echo Une erreur est survenue lors du clonage du dépôt Git.
    exit /b %errorlevel%
)

REM Déplacement vers le répertoire cloné
cd "%targetDirectory%"

REM Exécution du script PowerShell
powershell -ExecutionPolicy Bypass -File "%psScript%"

REM Ouvrir une nouvelle instance de PowerShell dans le répertoire cloné
start powershell /K "cd \"%targetDirectory%\""









@echo off

REM Définition des variables
set "repoUrl=https://github.com/votre-utilisateur/votre-repo.git"
set "targetDirectory=C:\chemin\vers\repertoire-cible"
set "psScript=nom-du-script.ps1"

REM Clonage du dépôt Git
git clone "%repoUrl%" "%targetDirectory%"

REM Vérification si le clonage a réussi
if %errorlevel% neq 0 (
    echo Une erreur est survenue lors du clonage du dépôt Git.
    exit /b %errorlevel%
)

REM Déplacement vers le répertoire cloné
cd "%targetDirectory%"

REM Exécution du script PowerShell
powershell -ExecutionPolicy Bypass -File "%psScript%"

REM Ouvrir une nouvelle instance de PowerShell dans le répertoire cloné
start powershell -NoExit -Command "cd \"%targetDirectory%\""






Oui, il est possible de changer le prompt pour revenir à l'invite de commande de PowerShell après l'exécution du script .ps1. Cependant, cela ne peut pas être fait directement depuis le script batch, car l'exécution d'un script PowerShell depuis un script batch se fait dans un processus distinct.

Une solution consiste à créer un profil PowerShell personnalisé qui sera chargé chaque fois que vous ouvrez une nouvelle session PowerShell. Dans ce profil, vous pouvez définir le prompt selon vos préférences.

Voici comment procéder :

Ouvrez une session PowerShell.
Exécutez la commande suivante pour vérifier si vous avez déjà un profil PowerShell existant :
powershell
Copy code
Test-Path $Profile
Si cela renvoie False, cela signifie que vous n'avez pas de profil existant. Dans ce cas, passez à l'étape 3. Sinon, passez à l'étape 4.
Exécutez la commande suivante pour créer un profil PowerShell :
powershell
Copy code
New-Item -Path $Profile -ItemType File -Force
Ouvrez le profil PowerShell dans votre éditeur de texte préféré en exécutant la commande suivante :
powershell
Copy code
notepad.exe $Profile
Si vous utilisez un autre éditeur de texte, remplacez notepad.exe par le chemin vers votre éditeur.
Dans le fichier du profil PowerShell, ajoutez la ligne suivante pour définir le prompt selon vos préférences :
powershell
Copy code
function prompt {
    "PS $($executionContext.SessionState.Path.CurrentLocation)$('>' * ($nestedPromptLevel + 1)) "
}
Cette ligne définit le prompt pour afficher "PS" suivi du chemin actuel et d'un nombre croissant de caractères ">", en fonction du niveau de prompt imbriqué.
Enregistrez et fermez le fichier.
Fermez toutes les instances de PowerShell existantes et ouvrez une nouvelle session PowerShell.
Maintenant, lorsque vous exécutez votre script .ps1 à partir du script batch, une fois le script terminé, vous devriez revenir à l'invite de commande de PowerShell avec le prompt personnalisé que vous avez défini dans votre profil PowerShell.

Notez que cela affectera tous les prompts dans PowerShell, pas seulement après l'exécution du script .ps1.
