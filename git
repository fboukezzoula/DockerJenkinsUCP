$timeout = New-TimeSpan -Minutes 5
$endTime = (Get-Date).AddMinutes(5)
$continue = $false

Write-Host "Appuyez sur la touche Entrée pour continuer..."
$null = $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

while ((Get-Date) -lt $endTime) {
    if ($host.UI.RawUI.KeyAvailable) {
        $key = $host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        if ($key.Key -eq "Enter") {
            $continue = $true
            break
        }
    }
    Start-Sleep -Milliseconds 100
}

if (-not $continue) {
    Write-Host "Temps écoulé. Sortie en erreur."
    exit 1
}

# Le script continue ici
Write-Host "Continuer le traitement..."
# Votre code supplémentaire





name: HelloWorld Paralell Jobs

on:
  workflow_dispatch:
    inputs:
      launcher:
        description: 'Person to launch this workflow'
        required: false
        default: 'Fouzi'

env:
  MYPAT: ${{ secrets.MYPAT }}
  SHA: ${{ github.sha }}
  AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
  AZURE_STORAGE_ACCESS_KEY: ${{ secrets.AZURE_STORAGE_ACCESS_KEY }}

jobs:
   Job01:
    timeout-minutes: 10
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.MYPAT }}
      - name: Build image
        env:
          ACR_NAME: ${{ secrets.ACR_NAME }}
        run: make build
      - name: Login to container registry
        env:
          SERVICE_PRINCIPAL_APP_ID: ${{ secrets.SERVICE_PRINCIPAL_APP_ID }}
          SERVICE_PRINCIPAL_SECRET: ${{ secrets.SERVICE_PRINCIPAL_SECRET }}
          SERVICE_PRINCIPAL_TENANT: ${{ secrets.SERVICE_PRINCIPAL_TENANT }}
          ACR_NAME: ${{ secrets.ACR_NAME }}
        run: make registry-login
      - name: Push image
        env:
          ACR_NAME: ${{ secrets.ACR_NAME }}
        run: make push
      - name: Get AKS credentials
        env:
          CLUSTER_RESOURCE_GROUP_NAME: ${{ secrets.CLUSTER_RESOURCE_GROUP_NAME }}
          CLUSTER_NAME: ${{ secrets.CLUSTER_NAME }}
        run: |
          az aks get-credentials \
            --resource-group $CLUSTER_RESOURCE_GROUP_NAME \
            --name $CLUSTER_NAME \
            --overwrite-existing
      - name: Deploy application
        env:
          ACR_NAME: ${{ secrets.ACR_NAME }}
        run: make deploy 
      - name: Create new file and upload it to blob container
        run: |
          mkdir -p /tmp/buildhelloworld
          touch /tmp/buildhelloworld/build_number_$(date '+%Y%m%d%H%M%S').txt 

          cd /tmp/buildhelloworld/
          # Upload sample files to container
          az storage blob upload-batch --connection-string "${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" -d showcase -s . --overwrite
      - name: Launch the workflow with API
        env:
          MYPAT: ${{ secrets.MYPAT }}
        run: |
          curl -X POST \
            --header "Authorization: Bearer $MYPAT" \
            --header "Accept: application/vnd.github.v3+json" \
            --url "https://api.github.com/repos/fboukezzoula/helloworld/actions/workflows/AKS_workflow.yml/dispatches" \
            --data '{"ref":"main", "inputs": { "launcher":"Fouzi"}}'

   Job02:
    timeout-minutes: 10
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.MYPAT }}
      - name: Build image
        env:
          ACR_NAME: ${{ secrets.ACR_NAME }}
        run: make build
      - name: Login to container registry
        env:
          SERVICE_PRINCIPAL_APP_ID: ${{ secrets.SERVICE_PRINCIPAL_APP_ID }}
          SERVICE_PRINCIPAL_SECRET: ${{ secrets.SERVICE_PRINCIPAL_SECRET }}
          SERVICE_PRINCIPAL_TENANT: ${{ secrets.SERVICE_PRINCIPAL_TENANT }}
          ACR_NAME: ${{ secrets.ACR_NAME }}
        run: make registry-login
      - name: Push image
        env:
          ACR_NAME: ${{ secrets.ACR_NAME }}
        run: make push
      - name: Get AKS credentials
        env:
          CLUSTER_RESOURCE_GROUP_NAME: ${{ secrets.CLUSTER_RESOURCE_GROUP_NAME }}
          CLUSTER_NAME: ${{ secrets.CLUSTER_NAME }}
        run: |
          az aks get-credentials \
            --resource-group $CLUSTER_RESOURCE_GROUP_NAME \
            --name $CLUSTER_NAME \
            --overwrite-existing
      - name: Deploy application
        env:
          ACR_NAME: ${{ secrets.ACR_NAME }}
        run: make deploy 
      - name: Create new file and upload it to blob container
        run: |
          mkdir -p /tmp/buildhelloworld
          touch /tmp/buildhelloworld/build_number_$(date '+%Y%m%d%H%M%S').txt 

          cd /tmp/buildhelloworld/
          # Upload sample files to container
          az storage blob upload-batch --connection-string "${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" -d showcase -s . --overwrite
      - name: Launch the workflow with API
        env:
          MYPAT: ${{ secrets.MYPAT }}
        run: |
          curl -X POST \
            --header "Authorization: Bearer $MYPAT" \
            --header "Accept: application/vnd.github.v3+json" \
            --url "https://api.github.com/repos/fboukezzoula/helloworld/actions/workflows/AKS_workflow.yml/dispatches" \
            --data '{"ref":"main", "inputs": { "launcher":"Fouzi"}}'



git commit --amend --no-edit



$response = Invoke-RestMethod -Uri "https://api.example.com" -Method GET
$resultat = $response.RawContent -split "`n"

# Parcourir chaque ligne du résultat
foreach ($ligne in $resultat) {
    # Vérifier si la ligne contient la chaîne de caractères spécifique
    if ($ligne -like "*chaîne de caractères*") {
        $ligne  # Afficher la ligne trouvée
        break  # Sortir de la boucle une fois que la ligne est trouvée
    }
}






$response = Invoke-RestMethod -Uri "https://api.example.com" -Method GET
$resultat = $response.RawContent

# Recherche de la ligne contenant la chaîne de caractères spécifique
$line = $resultat | Select-String -Pattern "chaîne de caractères"

# Affichage de la ligne trouvée
$line.Line




$chromeProcess = Start-Process "chrome.exe" -ArgumentList "http://URL" -PassThru
Start-Sleep -Seconds 5  # Attendre que Chrome se lance (ajustez si nécessaire)

$pinvokeCode = @'
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

public class WindowHelper
{
    [DllImport("user32.dll")]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

    [DllImport("user32.dll")]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

    public const int SW_MINIMIZE = 6;
}

public class ChromeHelper
{
    public static void MinimizeChrome()
    {
        Process[] chromeProcesses = Process.GetProcessesByName("chrome");
        foreach (Process chromeProcess in chromeProcesses)
        {
            IntPtr chromeMainWindowHandle = chromeProcess.MainWindowHandle;
            WindowHelper.ShowWindow(chromeMainWindowHandle, WindowHelper.SW_MINIMIZE);
        }
    }
}
'@

Add-Type -TypeDefinition $pinvokeCode
[ChromeHelper]::MinimizeChrome()






# Chemin vers la clé de registre contenant le navigateur par défaut
$browserRegistryPath = "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice"
$browserRegistryValue = "ProgId"

# Lire la valeur du registre pour récupérer le navigateur par défaut
$defaultBrowser = (Get-ItemProperty -Path $browserRegistryPath -Name $browserRegistryValue).$browserRegistryValue

# Ouvrir la page en fonction du navigateur par défaut
switch ($defaultBrowser) {
    "ChromeHTML" {
        Start-Process chrome.exe -ArgumentList "http://URL" --start-minimized
        break
    }
    "AppXq0fevzme2pys62n3e0fbqa7peapykr8v" {
        Start-Process msedge.exe -ArgumentList "http://URL" -WindowStyle Minimized
        break
    }
    # Ajoutez d'autres cas pour les navigateurs supplémentaires
    default {
        Write-Host "Navigateur par défaut non pris en charge."
    }
}



#Ouvrir Microsoft Edge
Start-Process microsoft-edge

# Attendre que le navigateur soit prêt
while (!(Get-Process microsoft-edge -ErrorAction SilentlyContinue)) {
    Start-Sleep -Milliseconds 100
}

# Naviguer vers une page (vous pouvez remplacer "https://example.com" par votre URL)
Start-Process microsoft-edge -ArgumentList "https://example.com"

# Attendre que la page soit complètement chargée
while ((Invoke-WebRequest -Uri "https://example.com" -Method Head).StatusCode -ne 200) {
    Start-Sleep -Milliseconds 100
}

# Copier le contenu du presse-papiers dans le champ de saisie
$clipboardData = Get-Clipboard
$edgeProcess = Get-Process microsoft-edge
$edgeMainWindowHandle = $edgeProcess.MainWindowHandle
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;

public class ClipboardHelper
{
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool SetForegroundWindow(IntPtr hWnd);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);
}

public class Win32Constants
{
    public const uint WM_SETTEXT = 0x000C;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_KEYUP = 0x0101;
    public const int VK_CONTROL = 0x11;
    public const int VK_V = 0x56;
    public const int VK_RETURN = 0x0D;
}
"@

$edgeWindowHandle = [ClipboardHelper]::FindWindow(null, $edgeMainWindowHandle.MainWindowTitle)
$edgeAddressBarHandle = [ClipboardHelper]::FindWindowEx($edgeWindowHandle, IntPtr::Zero, "Edit", null)
[ClipboardHelper]::SetForegroundWindow($edgeAddressBarHandle)
[ClipboardHelper]::SendMessage($edgeAddressBarHandle, [Win32Constants]::WM_SETTEXT, IntPtr::Zero, [IntPtr]::Zero)
[System.Windows.Forms.SendKeys]::SendWait("$clipboardData")

# Rechercher et cliquer sur le bouton "OK"
Start-Sleep -Seconds 2  # Attendre quelques secondes pour laisser le texte se coller dans la barre d'adresse
$edgeAddressBarHandle = [ClipboardHelper]::FindWindowEx($edgeWindowHandle, IntPtr::Zero, "Edit", null)
$edgeAddressBarHandle | Out-Null  # Supprimer la sortie
[ClipboardHelper]::SendMessage($edgeAddressBarHandle, [Win32Constants]::WM_KEYDOWN, [IntPtr]::new([Win32Constants]::VK_RETURN), [IntPtr]::Zero)
[ClipboardHelper]::SendMessage($edgeAddressBarHandle, [Win32Constants]::WM_KEYUP, [IntPtr]::new([Win32Constants]::VK_RETURN), [IntPtr]::Zero)




# Ouvrir le navigateur
$ie = New-Object -ComObject InternetExplorer.Application
$ie.Visible = $true

# Attendre que le navigateur soit prêt
while ($ie.Busy) {
    Start-Sleep -Milliseconds 100
}

# Naviguer vers une page (vous pouvez remplacer "https://example.com" par votre URL)
$ie.Navigate("https://example.com")

# Attendre que la page soit complètement chargée
while ($ie.ReadyState -ne 4) {
    Start-Sleep -Milliseconds 100
}

# Copier le contenu du presse-papiers dans le champ de saisie
$clipboardData = Get-Clipboard
$ie.Document.getElementById("id_du_champ_de_saisie").value = $clipboardData

# Fermer le navigateur (vous pouvez commenter cette ligne si vous souhaitez le laisser ouvert)
$ie.Quit()


# Rechercher et cliquer sur le bouton "OK"
$okButton = $ie.Document.getElementById("id_du_bouton_OK")
$okButton.click()



git checkout <branch_name_to_be_squashed>
git rebase -i HEAD~<count>
git push --force-with-lease










C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -File VotreScript.ps1

Start-Process cmd.exe -ArgumentList "/c commande1 && commande2"


ssh -i chemin_vers_la_clé_privée utilisateur@adresse_serveur




HOW TO CONNECT VIA SSH FROM POWERSHELL
July 11, 2012
On codeplex (http://sshnet.codeplex.com/) there is a library that can be used for create a powershell SSH client (http://www.powershelladmin.com/wiki/SSH_from_PowerShell_using_the_SSH.NET_library).

First download the library from http://sshnet.codeplex.com/. I used SshNet 4.0 version (you need .net 4.0 installed on your machine).

Check on your powershell the correct path where store the modules:

$env:PSModulePath
Create inside one of the modules paths a folder called SSH-Modules.
In my case: C:\Users\aduser\Documents\WindowsPowerShell\Modules\SSH-Sessions
I put it on my profile, so usable only from my user.

Put the file Renci.SshNet.dll you have downloaded before inside SSH-Sessions

From http://www.powershelladmin.com/wiki/SSH_from_PowerShell_using_the_SSH.NET_library I downloaded the file SSH-Sessions.psd1 and modify it to work with version 4 of library:

# Module manifest for module 'SSH-Sessions.psm1'
#
# Created by: Joakim Svendsen
#
# Created on: 2012-04-19
#
@{

# Script module or binary module file associated with this manifest
ModuleToProcess = 'SSH-Sessions.psm1'

# Version number of this module.
ModuleVersion = '1.04'

# ID used to uniquely identify this module
GUID = ''

# Author of this module
Author = 'Joakim Svendsen'

# Company or vendor of this module
CompanyName = 'Svendsen Tech'

# Copyright statement for this module
Copyright = 'Copyright (c) 2012, Svendsen Tech. All rights reserved.'

# Description of the functionality provided by this module
Description = 'Provides SSH session creation, management and interaction from PowerShell'

# Minimum version of the Windows PowerShell engine required by this module
PowerShellVersion = '2.0'

# Name of the Windows PowerShell host required by this module
PowerShellHostName = ''

# Minimum version of the Windows PowerShell host required by this module
PowerShellHostVersion = ''

# Minimum version of the .NET Framework required by this module
DotNetFrameworkVersion = '4.0'

# Minimum version of the common language runtime (CLR) required by this module
CLRVersion = ''

# Processor architecture (None, X86, Amd64, IA64) required by this module
ProcessorArchitecture = ''

# Modules that must be imported into the global environment prior to importing this module
RequiredModules = @()

# Assemblies that must be loaded prior to importing this module
RequiredAssemblies = @('Renci.SshNet.dll')

# Script files (.ps1) that are run in the caller's environment prior to importing this module
ScriptsToProcess = @()

# Type files (.ps1xml) to be loaded when importing this module
TypesToProcess = @()

# Format files (.ps1xml) to be loaded when importing this module
FormatsToProcess = @()

# Modules to import as nested modules of the module specified in ModuleToProcess
NestedModules = @()

# Functions to export from this module
FunctionsToExport = '*'

# Cmdlets to export from this module
CmdletsToExport = '*'

# Variables to export from this module
VariablesToExport = '*'

# Aliases to export from this module
AliasesToExport = '*'

# List of all modules packaged with this module
ModuleList = @()

# List of all files packaged with this module
FileList = @('Renci.SshNet.dll', 'SSH-Sessions.psm1', 'SSH-Sessions.psd1')

# Private data to pass to the module specified in ModuleToProcess
PrivateData = ''

}
Same for file SSH-Sessions.psm1

# Function to convert a secure string to a plain text password.
# See http://www.powershelladmin.com/wiki/Powershell_prompt_for_password_convert_securestring_to_plain_text
function ConvertFrom-SecureToPlain {

    param( [Parameter(Mandatory=$true)][System.Security.SecureString] $SecurePassword)

    # Create a "password pointer"
    $PasswordPointer = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePassword)

    # Get the plain text version of the password
    $PlainTextPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto($PasswordPointer)

    # Free the pointer
    [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($PasswordPointer)

    # Return the plain text password
    $PlainTextPassword

}

function New-SshSession {

    param([Parameter(Mandatory=$true)][string[]] $ComputerName,
          [Parameter(Mandatory=$true)][string]   $Username,
          [string] $KeyFile = '',
          [string] $Password = 'SvendsenTechDefault', # I guess allowing for a blank password is "wise"...
          [int] $Port = 22
    )

    if ($KeyFile -ne '') {

        "Key file specified. Will override password. Trying to read key file..."

        if (Test-Path -PathType Leaf -Path $Keyfile) {

            $Key = New-Object Renci.SshNet.PrivateKeyFile( $Keyfile )

        }

        else {

            "Specified keyfile does not exist: '$KeyFile'."
            return

        }

    }

    else {

        $Key = $false

    }

    # Prompt for password if none was supplied on the command line, and no key was provided.
    if (-not $Key -and $Password -ceq 'SvendsenTechDefault') {

        $SecurePassword = Read-Host -AsSecureString "No key provided. Enter SSH password for $Username"
        $Password = ConvertFrom-SecureToPlain $SecurePassword

    }

    # Let's start creating sessions and storing them in $global:SshSessions
    foreach ($Computer in $ComputerName) {

        if ($global:SshSessions.ContainsKey($Computer) -and $global:SshSessions.$Computer.IsConnected) {

            "You are already connected to $Computer"
            continue

        }

        try {

            if ($Key) {

                $SshClient = New-Object Renci.SshNet.SshClient($Computer, $Port, $Username, $Key)

            }

            else {

                $SshClient = New-Object Renci.SshNet.SshClient($Computer, $Port, $Username, $Password)

            }

        }

        catch {

            "Unable to create SSH client object for ${Computer}: $_"
            continue

        }

        try {

            $SshClient.Connect()

        }

        catch {

            "Unable to connect to ${Computer}: $_"
            continue

        }

        if ($SshClient -and $SshClient.IsConnected) {

            "Successfully connected to $Computer"
            $global:SshSessions.$Computer = $SshClient

        }

        else {

            "Unable to connect to ${Computer}"
            continue

        }

    } # end of foreach

    # Shrug... Can't hurt although I guess they should go out of scope here anyway.
    $SecurePassword, $Password = $null, $null

}

function Invoke-SshCommand {

    param([string[]] $ComputerName, # can't have it mandatory due to -InvokeOnAll...
          [Parameter(Mandatory=$true)][string] $Command,
          [switch] $Quiet,
          [switch] $InvokeOnAll
    )

    if ($InvokeOnAll) {

        if ($ComputerName) {

            $Answer = Read-Host -Prompt "You specified both -InvokeOnAll and -ComputerName. -InvokeOnAll overrides and targets all hosts.`nAre you sure you want to continue? (y/n) [yes]"
            if ($Answer -imatch '^n') { return }

        }

        if ($global:SshSessions.Keys.Count -eq 0) {

            "-InvokeOnAll specified, but no hosts found."
            return

        }

        # Get all computer names from the global SshSessions hashtable.
        $ComputerName = $global:SshSessions.Keys | Sort-Object

    }

    if (-not $ComputerName) {

        "No computer names specified and -InvokeOnAll not specified. Can not continue."
        return

    }

    foreach ($Computer in $ComputerName) {

        if (-not $global:SshSessions.ContainsKey($Computer)) {

            Write-Host -Fore Red "No SSH session found for $Computer. See Get-Help New-SshSession. Skipping."
            "No SSH session found for $Computer. See Get-Help New-SshSession. Skipping."
            continue

        }

        if (-not $global:SshSessions.$Computer.IsConnected) {

            Write-Host -Fore Red "You are no longer connected to $Computer. Skipping."
            "You are no longer connected to $Computer. Skipping."
            continue

        }

        $CommandObject = $global:SshSessions.$Computer.RunCommand($Command)

        # Write pretty, colored results with Write-Host unless the quiet switch is provided.
        if (-not $Quiet) {

            if ($CommandObject.ExitStatus -eq 0) {

                Write-Host -Fore Green -NoNewline "${Computer}: "
                Write-Host -Fore Cyan ($CommandObject.Result -replace '[\r\n]+\z', '')

            }

            else {

                Write-Host -Fore Green -NoNewline "${Computer} "
                Write-Host -Fore Yellow 'had an error:' ($CommandObject.Error -replace '[\r\n]+\z', '')

            }

        }

        # Now emit to the pipeline
        if ($CommandObject.ExitStatus -eq 0) {

            # Emit results to the pipeline. Twice the fun unless you're assigning the results to a variable.
            # Changed from .Trim(). Remove the trailing carriage returns and newlines that might be there,
            # in case leading whitespace matters in later processing. Not sure I should even be doing this.
            $CommandObject.Result -replace '[\r\n]+\z', ''

        }

        else {

            # Emit error to the pipeline. Twice the fun unless you're assigning the results to a variable.
            # Changed from .Trim(). Remove the trailing carriage returns and newlines that might be there,
            # in case leading whitespace matters in later processing. Not sure I should even be doing this.
            $CommandObject.Error -replace '[\r\n]+\z', ''

        }

        $CommandObject.Dispose()
        $CommandObject = $null

    }

}

function Enter-SshSession {

    param([Parameter(Mandatory=$true)][string] $ComputerName,
          [switch] $NoPwd
    )

    if (-not $global:SshSessions.ContainsKey($ComputerName)) {

        "No SSH session found for $Computer. See Get-Help New-SshSession. Skipping."
        return

    }

    if (-not $global:SshSessions.$ComputerName.IsConnected) {

        "The connection to $Computer has been lost"
        return

    }

    $SshPwd = ''

    # Get the default working dir of the user (won't be updated...)
    if (-not $NoPwd) {

        $SshPwdResult = $global:SshSessions.$ComputerName.RunCommand('pwd')

        if ($SshPwdResult.ExitStatus -eq 0) {

            $SshPwd = $SshPwdResult.Result.Trim()

        }

        else {

            $SshPwd = '(pwd failed)'

        }

    }

    $Command = ''

    while (1) {

        if (-not $global:SshSessions.$ComputerName.IsConnected) {

            "Connection to $Computer lost"
            return

        }

        $Command = Read-Host -Prompt "[$ComputerName]: $SshPwd # "

        # Break out of the infinite loop if they type "exit" or "quit"
        if ($Command -ieq 'exit' -or $Command -ieq 'quit') { break }

        $Result = $global:SshSessions.$ComputerName.RunCommand($Command)

        if ($Result.ExitStatus -eq 0) {

            $Result.Result -replace '[\r\n]+\z', ''

        }

        else {

            $Result.Error -replace '[\r\n]+\z', ''

        }

    } # end of while

}

function Remove-SshSession {

    param([string[]] $ComputerName, # can't have it mandatory due to -RemoveAll
          [switch]   $RemoveAll
    )

    if ($RemoveAll) {

        if ($ComputerName) {

            $Answer = Read-Host -Prompt "You specified both -RemoveAll and -ComputerName. -RemoveAll overrides and removes all connections.`nAre you sure you want to continue? (y/n) [yes]"
            if ($Answer -imatch '^n') { return }

        }

        if ($global:SshSessions.Keys.Count -eq 0) {

            "-RemoveAll specified, but no hosts found."
            return

        }

        # Get all computer names from the global SshSessions hashtable.
        $ComputerName = $global:SshSessions.Keys | Sort-Object

    }

    if (-not $ComputerName) {

        "No computer names specified and -RemoveAll not specified. Can not continue."
        return

    }

    foreach ($Computer in $ComputerName) {

        if (-not $global:SshSessions.ContainsKey($Computer)) {

            "The global `$SshSessions variable doesn't contain a session for $Computer. Skipping."
            continue

        }

        $ErrorActionPreference = 'Continue'

        if ($global:SshSessions.$Computer.IsConnected) { $global:SshSessions.$Computer.Disconnect() }
        $global:SshSessions.$Computer.Dispose()
        $global:SshSessions.$Computer = $null
        $global:SshSessions.Remove($Computer)

        $ErrorActionPreferene = 'Stop'

        "$Computer should now be disconnected and disposed."

    }

}

function Get-SshSession {

    param( [string[]] $ComputerName )

    # Just exit with a message if there aren't any connections.
    if ($global:SshSessions.Count -eq 0) { "No connections found"; return }

    # Unless $ComputerName is specified, use all hosts in the global variable, sorted alphabetically.
    if (-not $ComputerName) { $ComputerName = $global:SshSessions.Keys | Sort-Object }

    $Properties =
        @{n='ComputerName';e={$_}},
        @{n='Connected';e={

            # Ok, this isn't too pretty... Populate non-existing objects'
            # "connected" value with "NULL".
            if ($global:SshSessions.ContainsKey($_)) {

                $global:SshSessions.$_.IsConnected

            }
            else {

                'NULL'

            }
        }}

    # Process the hosts and emit output to the pipeline.
    $ComputerName | Select-Object $Properties

}

######## END OF FUNCTIONS ########

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

$global:SshSessions = @{}

Export-ModuleMember New-SshSession, Invoke-SshCommand, Enter-SshSession, `
                    Remove-SshSession, Get-SshSession, ConvertFrom-SecureToPlain
Copy the files SSH-Sessions.psd1 and SSH-Sessions.psm1 inside the module folder SSH-Sessions.

You are now ready to lunch powershell and import SSH-Modules:

Import-Module SSH-Sessions
Create a new SSH Session:

New-SshSession -ComputerName 192.168.1.1 -Username MyUser
Advertisements

REPORT THIS ADPRIVACY

and enter to interactive session:

Enter-SshSession -ComputerName 192.168.1.1
for disconnect ssh session use this command:

Remove-SshSession -RemoveAll
Remember to modify security on powershell making script running…

Via: http://www.powershelladmin.com/wiki/SSH_from_PowerShell_using_the_SSH.NET_library

Advertisements










$sshKeyPath = "D:\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"
$sshPublicKeyFile = "$sshKeyPath\id_rsa.pub"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant ssh-keygen
$sshKeyGenArgs = "-t rsa -b 4096 -N '$null' -f $sshKeyFile -q"
Start-Process -FilePath ssh-keygen -ArgumentList $sshKeyGenArgs -NoNewWindow -Wait

# Lire le contenu de la clé publique générée
$sshPublicKeyContent = Get-Content $sshPublicKeyFile

Write-Host "La clé SSH a été générée avec succès."
Write-Host "Clé privée : $sshKeyFile"
Write-Host "Clé publique : $sshPublicKeyFile"







$sshKeyPath = "D:\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"
$sshPublicKeyFile = "$sshKeyPath\id_rsa.pub"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant ssh-keygen
$sshKeyGenArgs = "-t rsa -b 4096 -N '' -f $sshKeyFile"
Start-Process -FilePath ssh-keygen -ArgumentList $sshKeyGenArgs -NoNewWindow -Wait

# Lire le contenu de la clé publique générée
$sshPublicKeyContent = Get-Content $sshPublicKeyFile

Write-Host "La clé SSH a été générée avec succès."
Write-Host "Clé privée : $sshKeyFile"
Write-Host "Clé publique : $sshPublicKeyFile"








Add-Type -Path "D:\ssh\BouncyCastle.Crypto.dll"

$sshKeyPath = "D:\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"
$sshPublicKeyFile = "$sshKeyPath\id_rsa.pub"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase
$generator = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$parameters = New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096
$generator.Init($parameters)

$keyPair = $generator.GenerateKeyPair()
$privateKey = $keyPair.Private

# Enregistrer la clé privée
$writer = New-Object System.IO.StringWriter
$format = New-Object Org.BouncyCastle.OpenSsl.PemWriter($writer)
$format.WriteObject($privateKey)
$format.Writer.Flush()
$privateKeyContent = $writer.ToString()
Set-Content -Path $sshKeyFile -Value $privateKeyContent

# Enregistrer la clé publique
$publicKey = $keyPair.Public
$publicKeyBytes = $publicKey.GetEncoded()
$publicKeyBase64 = [Convert]::ToBase64String($publicKeyBytes)
$publicKeyContent = "ssh-rsa $publicKeyBase64"
Set-Content -Path $sshPublicKeyFile -Value $publicKeyContent

Write-Host "La clé SSH a été générée avec succès."
Write-Host "Clé privée : $sshKeyFile"
Write-Host "Clé publique : $sshPublicKeyFile"








Add-Type -Path "D:\ssh\BouncyCastle.Crypto.dll"

$sshKeyPath = "D:\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase
$generator = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$parameters = New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096
$generator.Init($parameters)

$keyPair = $generator.GenerateKeyPair()
$privateKey = $keyPair.Private

$writer = New-Object System.IO.StringWriter
$format = New-Object Org.BouncyCastle.OpenSsl.PemWriter($writer)
$format.WriteObject($privateKey)
$format.Writer.Flush()
$privateKeyContent = $writer.ToString()

Set-Content -Path $sshKeyFile -Value $privateKeyContent

Write-Host "La clé SSH a été générée avec succès."






# Installation du module SSHKeyUtils depuis PowerShell Gallery
Install-Module -Name SSHKeyUtils -Scope CurrentUser -Force

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant SSHKeyUtils
$rsaKey = New-SSHKeyRSA -NoPassphrase -KeyLength 4096

# Enregistrer la clé privée dans le fichier
$rsaKey.PrivateKey | Out-File -FilePath $sshKeyFile -Encoding ASCII

Write-Host "La clé SSH a été générée avec succès."






Vous pouvez télécharger la bibliothèque BouncyCastle depuis le site officiel du projet sur GitHub. Voici les étapes pour télécharger et utiliser la bibliothèque BouncyCastle :

Accédez à la page GitHub de BouncyCastle : https://github.com/bcgit/bc-csharp

Cliquez sur le bouton vert "Code" et sélectionnez "Download ZIP" pour télécharger l'archive ZIP contenant le code source de BouncyCastle.

Extrayez le contenu de l'archive ZIP téléchargée sur votre ordinateur.

Dans le dossier extrait, accédez au sous-dossier bc-csharp\BouncyCastle.Crypto\bin\Release\net471 (ou à un autre sous-dossier approprié en fonction de votre environnement).

Dans ce sous-dossier, vous trouverez le fichier BouncyCastle.OpenSsl.dll. Copiez ce fichier dans le chemin C:\chemin\vers\ spécifié dans le script PowerShell.

Une fois que vous avez copié le fichier BouncyCastle.OpenSsl.dll dans le bon chemin, vous pouvez exécuter le script PowerShell que je vous ai fourni précédemment.

Veuillez noter que les chemins spécifiés (C:\chemin\vers\BouncyCastle.Crypto.dll et C:\chemin\vers\BouncyCastle.OpenSsl.dll) dans le script doivent être modifiés en fonction de l'emplacement réel où vous avez copié les fichiers DLL.

J'espère que cela vous aide. Si vous avez d'autres questions, n'hésitez pas à demander.



Add-Type -Path "C:\chemin\vers\BouncyCastle.Crypto.dll"
Add-Type -Path "C:\chemin\vers\BouncyCastle.OpenSsl.dll"

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant BouncyCastle
$keyGen = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$keyGen.Init((New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096))

$keyPair = $keyGen.GenerateKeyPair()

$privateKey = [Org.BouncyCastle.OpenSsl.PemWriter]::ToPemString($keyPair.Private)
$publicKey = [Org.BouncyCastle.OpenSsl.PemWriter]::ToPemString($keyPair.Public)

Set-Content -Path $sshKeyFile -Value $privateKey

Write-Host "La clé SSH a été générée avec succès."




$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant le module OpenSSH
$null = New-Item -ItemType File -Path "$sshKeyPath\config" -Force

$sshKeyGenCommand = "ssh-keygen -t rsa -b 4096 -N '' -f $sshKeyFile"
$null = Invoke-Expression -Command $sshKeyGenCommand

Write-Host "La clé SSH a été générée avec succès."




$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant ssh-keygen
$sshKeyGenArgs = "-t rsa -b 4096 -f $sshKeyFile"
Start-Process -FilePath ssh-keygen -ArgumentList $sshKeyGenArgs -NoNewWindow -Wait

Write-Host "La clé SSH a été générée avec succès."







$sshKeygenCommand = "ssh-keygen -t rsa -b 4096 -N '' -f $sshKeyFile"
$null = Invoke-Expression -Command $sshKeygenCommand







Add-Type -Path "C:\chemin\vers\BouncyCastle.Crypto.dll"

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

$keyGen = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$keyGen.Init((New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096))

$keyPair = $keyGen.GenerateKeyPair()
$privateKeyInfo = [Org.BouncyCastle.Security.PrivateKeyInfo]::Factory.CreatePrivateKeyInfo($keyPair.Private)
$privateKeyContent = [System.Convert]::ToBase64String($privateKeyInfo.GetEncoded())

Set-Content -Path $sshKeyFile -Value "-----BEGIN OPENSSH PRIVATE KEY-----`n$privateKeyContent`n-----END OPENSSH PRIVATE KEY-----"

Write-Host "La clé SSH a été générée avec succès."








Add-Type -Path "C:\chemin\vers\BouncyCastle.Crypto.dll"

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

$keyGen = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$keyGen.Init((New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096))

$keyPair = $keyGen.GenerateKeyPair()
$privateKeyInfo = [Org.BouncyCastle.OpenSsl.PemWriter]::ToPemObject($keyPair.Private)
$privateKeyContent = [System.Text.Encoding]::ASCII.GetBytes($privateKeyInfo.Content)

Set-Content -Path $sshKeyFile -Value $privateKeyContent -Encoding Byte

Write-Host "La clé SSH a été générée avec succès."






# Installer le module SSH.NET s'il n'est pas déjà installé
if (-not (Get-Module -ListAvailable -Name SSH.NET)) {
    Install-Module -Name SSH.NET -Scope CurrentUser -Force
}

# Importer le module SSH.NET
Import-Module -Name SSH.NET

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant SSH.NET
$rsaKey = [Renci.SshNet.SecurityKeyFactory]::KeyGenerate('RSA', 4096)
$privateKeyContent = [Renci.SshNet.PrivateKeyFile]::new($rsaKey).GetBytes()

Set-Content -Path $sshKeyFile -Value $privateKeyContent -Encoding Byte

Write-Host "La clé SSH a été générée avec succès."






Add-Type -Path "C:\chemin\vers\BouncyCastle.Crypto.dll"

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

$generator = New-Object Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator
$parameters = New-Object Org.BouncyCastle.Crypto.KeyGenerationParameters -ArgumentList (New-Object Org.BouncyCastle.Security.SecureRandom), 4096
$generator.Init($parameters)

$keyPair = $generator.GenerateKeyPair()

$privateKey = $keyPair.Private

$privateKeyContent = [Convert]::ToBase64String($privateKey.GetEncoded())

Set-Content -Path $sshKeyFile -Value "-----BEGIN OPENSSH PRIVATE KEY-----`n$privateKeyContent`n-----END OPENSSH PRIVATE KEY-----"

Write-Host "La clé SSH a été générée avec succès."







https://www.powershellgallery.com/packages/SSH/1.0.0


# Importer les modules requis
Add-Type -Path (Join-Path (Get-Package -Name BouncyCastle).Source 'lib\netstandard2.0\BouncyCastle.Crypto.dll')

# Définir les paramètres pour la clé SSH
$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Générer une nouvelle clé SSH RSA sans passphrase
$keyPairGenerator = [BouncyCastle.Crypto.Generators.RsaKeyPairGenerator]::new()
$keyParams = [BouncyCastle.Crypto.KeyGenerationParameters]::new($null, 4096)
$keyPairGenerator.Init($keyParams)
$keyPair = $keyPairGenerator.GenerateKeyPair()

$privateKeyInfo = [BouncyCastle.OpenSsl.PemWriter]::new([System.IO.File]::CreateText($sshKeyFile))
$privateKeyInfo.WriteObject($keyPair.Private)
$privateKeyInfo.Writer.Close()

Write-Host "La clé SSH a été générée avec succès."


# Importer le module SSH.NET
Import-Module -Name SSH.NET

# Définir les paramètres pour la clé SSH
$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant SSH.NET
$rsaKey = [Renci.SshNet.SecurityKeyFactory]::KeyGenerate('RSA', 4096)
$privateKey = [Renci.SshNet.PrivateKeyFile]::Create($sshKeyFile, $rsaKey, '')

Write-Host "La clé SSH a été générée avec succès."




$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant ssh-keygen
$sshKeyGenArgs = "-t rsa -b 4096 -N '' -f $sshKeyFile"
Start-Process -FilePath ssh-keygen -ArgumentList $sshKeyGenArgs -NoNewWindow -Wait

Write-Host "La clé SSH a été générée avec succès."





# Installer le module Posh-SSH s'il n'est pas déjà installé
if (-not (Get-Module -ListAvailable -Name Posh-SSH)) {
    Install-Module -Name Posh-SSH -Force
}

$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant Posh-SSH
$rsaKey = New-SSHKey -Path $sshKeyFile -KeyLength 4096

Write-Host "La clé SSH a été générée avec succès."


if (Get-Module -ListAvailable -Name OpenSSH) {
    Write-Host "OpenSSH est installé sur ce système."
}
else {
    Write-Host "OpenSSH n'est pas installé sur ce système."
}


$sshKeyPath = "C:\chemin\vers\la\clé\ssh"
$sshKeyFile = "$sshKeyPath\id_rsa"

# Vérification si le dossier de la clé SSH existe et le créer s'il n'existe pas
if (!(Test-Path $sshKeyPath)) {
    New-Item -ItemType Directory -Path $sshKeyPath | Out-Null
}

# Vérification si la clé SSH existe déjà et supprimer la clé existante
if (Test-Path $sshKeyFile) {
    Remove-Item $sshKeyFile
}

# Générer une nouvelle clé SSH RSA sans passphrase en utilisant OpenSSH
$sshKeyGenArgs = "-t rsa -b 4096 -N '' -f $sshKeyFile"
& ssh-keygen $sshKeyGenArgs

Write-Host "La clé SSH a été générée avec succès."



@echo off

REM Définition des variables
set "repoUrl=https://github.com/votre-utilisateur/votre-repo.git"
set "targetDirectory=C:\chemin\vers\repertoire-cible"
set "psScript=nom-du-script.ps1"
set "argument=argument-du-script"

REM Vérification si le répertoire cible existe et le supprimer s'il existe
if exist "%targetDirectory%" (
    echo Suppression du répertoire cible existant...
    rmdir /s /q "%targetDirectory%"
)

REM Clonage du dépôt Git
git clone "%repoUrl%" "%targetDirectory%"

REM Vérification si le clonage a réussi
if %errorlevel% neq 0 (
    echo Une erreur est survenue lors du clonage du dépôt Git.
    exit /b %errorlevel%
)

REM Déplacement vers le répertoire cloné
cd "%targetDirectory%"

REM Exécution du script PowerShell avec l'argument spécifié
powershell -ExecutionPolicy Bypass -File "%psScript%" -argument "%argument%"

REM Ouvrir une nouvelle instance de PowerShell dans le répertoire cloné
start powershell -NoExit -Command "cd \"%targetDirectory%\""



@echo off

REM Définition des variables
set "repoUrl=https://github.com/votre-utilisateur/votre-repo.git"
set "targetDirectory=C:\chemin\vers\repertoire-cible"
set "psScript=nom-du-script.ps1"

REM Clonage du dépôt Git
git clone "%repoUrl%" "%targetDirectory%"

REM Vérification si le clonage a réussi
if %errorlevel% neq 0 (
    echo Une erreur est survenue lors du clonage du dépôt Git.
    exit /b %errorlevel%
)

REM Déplacement vers le répertoire cloné
cd "%targetDirectory%"

REM Exécution du script PowerShell
powershell -ExecutionPolicy Bypass -File "%psScript%"






@echo off

REM Définition des variables
set "repoUrl=https://github.com/votre-utilisateur/votre-repo.git"
set "targetDirectory=C:\chemin\vers\repertoire-cible"
set "psScript=nom-du-script.ps1"

REM Clonage du dépôt Git
git clone "%repoUrl%" "%targetDirectory%"

REM Vérification si le clonage a réussi
if %errorlevel% neq 0 (
    echo Une erreur est survenue lors du clonage du dépôt Git.
    exit /b %errorlevel%
)

REM Déplacement vers le répertoire cloné
cd "%targetDirectory%"

REM Exécution du script PowerShell
powershell -ExecutionPolicy Bypass -File "%psScript%"

REM Ouvrir une nouvelle instance de PowerShell dans le répertoire cloné
start powershell /K "cd \"%targetDirectory%\""









@echo off

REM Définition des variables
set "repoUrl=https://github.com/votre-utilisateur/votre-repo.git"
set "targetDirectory=C:\chemin\vers\repertoire-cible"
set "psScript=nom-du-script.ps1"

REM Clonage du dépôt Git
git clone "%repoUrl%" "%targetDirectory%"

REM Vérification si le clonage a réussi
if %errorlevel% neq 0 (
    echo Une erreur est survenue lors du clonage du dépôt Git.
    exit /b %errorlevel%
)

REM Déplacement vers le répertoire cloné
cd "%targetDirectory%"

REM Exécution du script PowerShell
powershell -ExecutionPolicy Bypass -File "%psScript%"

REM Ouvrir une nouvelle instance de PowerShell dans le répertoire cloné
start powershell -NoExit -Command "cd \"%targetDirectory%\""






Oui, il est possible de changer le prompt pour revenir à l'invite de commande de PowerShell après l'exécution du script .ps1. Cependant, cela ne peut pas être fait directement depuis le script batch, car l'exécution d'un script PowerShell depuis un script batch se fait dans un processus distinct.

Une solution consiste à créer un profil PowerShell personnalisé qui sera chargé chaque fois que vous ouvrez une nouvelle session PowerShell. Dans ce profil, vous pouvez définir le prompt selon vos préférences.

Voici comment procéder :

Ouvrez une session PowerShell.
Exécutez la commande suivante pour vérifier si vous avez déjà un profil PowerShell existant :
powershell
Copy code
Test-Path $Profile
Si cela renvoie False, cela signifie que vous n'avez pas de profil existant. Dans ce cas, passez à l'étape 3. Sinon, passez à l'étape 4.
Exécutez la commande suivante pour créer un profil PowerShell :
powershell
Copy code
New-Item -Path $Profile -ItemType File -Force
Ouvrez le profil PowerShell dans votre éditeur de texte préféré en exécutant la commande suivante :
powershell
Copy code
notepad.exe $Profile
Si vous utilisez un autre éditeur de texte, remplacez notepad.exe par le chemin vers votre éditeur.
Dans le fichier du profil PowerShell, ajoutez la ligne suivante pour définir le prompt selon vos préférences :
powershell
Copy code
function prompt {
    "PS $($executionContext.SessionState.Path.CurrentLocation)$('>' * ($nestedPromptLevel + 1)) "
}
Cette ligne définit le prompt pour afficher "PS" suivi du chemin actuel et d'un nombre croissant de caractères ">", en fonction du niveau de prompt imbriqué.
Enregistrez et fermez le fichier.
Fermez toutes les instances de PowerShell existantes et ouvrez une nouvelle session PowerShell.
Maintenant, lorsque vous exécutez votre script .ps1 à partir du script batch, une fois le script terminé, vous devriez revenir à l'invite de commande de PowerShell avec le prompt personnalisé que vous avez défini dans votre profil PowerShell.

Notez que cela affectera tous les prompts dans PowerShell, pas seulement après l'exécution du script .ps1.






Créez un fichier de service systemd avec la commande suivante :
bash
Copy code
sudo nano /etc/systemd/system/docker-prune.service
Ajoutez le code suivant dans le fichier :
makefile
Copy code
[Unit]
Description=Service de maintenance Docker pour nettoyer les ressources non utilisées
After=docker.service

[Service]
Type=oneshot
ExecStart=/usr/bin/docker system prune -f
WorkingDirectory=/
StandardOutput=journal
User=root

[Install]
WantedBy=multi-user.target
Enregistrez et fermez le fichier.

Exécutez la commande suivante pour recharger les fichiers de configuration systemd :

Copy code
sudo systemctl daemon-reload
Planifiez le service pour qu'il s'exécute tous les dimanches à 10h du matin en utilisant la commande suivante :
bash
Copy code
sudo systemctl enable --now docker-prune.timer
Cela devrait créer un service systemd appelé docker-prune.service qui nettoie les ressources non utilisées avec la commande docker system prune -f, et un minuteur systemd appelé docker-prune.timer qui déclenche le service tous les dimanches à 10h du matin.

Vous pouvez utiliser les commandes suivantes pour gérer le service :

Pour démarrer le service : sudo systemctl start docker-prune.service
Pour arrêter le service : sudo systemctl stop docker-prune.service
Pour redémarrer le service : sudo systemctl restart docker-prune.service
Pour afficher l'état du service : sudo systemctl status docker-prune.service

Pardon, j'ai omis d'inclure la définition de la planification dans les étapes. Voici comment planifier le service pour qu'il s'exécute tous les dimanches à 10h :

Créez un fichier de minuteur systemd avec la commande suivante :
bash
Copy code
sudo nano /etc/systemd/system/docker-prune.timer
Ajoutez le code suivant dans le fichier :
makefile
Copy code
[Unit]
Description=Timer for Docker maintenance service

[Timer]
OnCalendar=Sun 10:00:00
Unit=docker-prune.service

[Install]
WantedBy=timers.target
Enregistrez et fermez le fichier.

Exécutez la commande suivante pour recharger les fichiers de configuration systemd :

Copy code
sudo systemctl daemon-reload
Activez le minuteur pour qu'il démarre automatiquement à chaque redémarrage du système avec la commande suivante :
bash
Copy code
sudo systemctl enable docker-prune.timer
Maintenant, le service docker-prune.service sera déclenché par le minuteur docker-prune.timer tous les dimanches à 10h.

Vous pouvez utiliser les commandes suivantes pour gérer le minuteur :

Pour démarrer le minuteur : sudo systemctl start docker-prune.timer
Pour arrêter le minuteur : sudo systemctl stop docker-prune.timer
Pour afficher l'état du minuteur : sudo systemctl status docker-prune.timer
